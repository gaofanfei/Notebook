# B+树

上一篇文章[B树](https://zhuanlan.zhihu.com/p/208861039)介绍了B树，作为B树的一种变形，B+树在数据库领域中的应用同样非常广泛。本文首先介绍一下B+树的结构，然后给出B+树增、删、查对应的算法，最后讨论一下B+树与B树的异同点。

## 1. 结构

### 1.1. 节点结构

典型的B+树节点结构如下图所示，它最多包含n-1个搜索码值K<sub>1</sub>，K<sub>2</sub>，...，K<sub>n-1</sub>，以及n个指针P<sub>1</sub>，P<sub>2</sub>，...，P<sub>n</sub>，每个节点中搜索码值**排序存放**。

![wSi02Q.png](https://s1.ax1x.com/2020/09/02/wSi02Q.png)



#### 叶节点

叶节点指针P<sub>i</sub> (i = 1, 2, ..., n-1)指向具有搜索码Ki的一条文件记录，指针P<sub>n</sub>指向相邻的下一个叶节点。

因为各叶节点之间按照所含搜索码值大小有一个现行的顺序，所以用指针P<sub>n</sub>将叶节点按搜索码顺序串在一起，这种排序可以对文件进行高效的**顺序处理**。

![wSirKs.png](https://s1.ax1x.com/2020/09/02/wSirKs.png)



#### 非叶节点

B+树的非叶节点形成叶节点上的一个**多级（稀疏）索引**。非叶节点的结构和叶节点的相同，只不过非叶节点中所有的指针都是指向树中节点的指针。

让我们考虑一个包含m个指针的节点（m <= n），对于i = 2, 3, ..., m-1，指针P<sub>i</sub>指向一棵子树，该子树包含的搜索码值小于K<sub>i</sub> 且大于等于K<sub>i-1</sub>，指针P<sub>m</sub> 指向的子树中所含搜索码值大于等于K<sub>m-1</sub> ，指针P<sub>1</sub> 指向的子树中所含搜索码值小于K<sub>1</sub> 。

### 1.2.树结构 

一棵典型的B+树(n=4)如下图所示：

![wSiBvj.png](https://s1.ax1x.com/2020/09/02/wSiBvj.png)

从上图中可以看到，B+树中所有的数据指针（data pointer）都在叶节点中，而B树中数据指针在叶节点和非叶节点中。B+树中相邻叶节点通过指针组成一个链表，而B树相邻叶节点之间没有指针。



## 2. 查找

### 算法

```
function find(v)
/* Assumes no duplicate keys, and returns pointer to the record with
* search key value v if such a record exists, and null otherwise */
	Set C = root node
	while (C is not a leaf node) begin
		Let i = smallest number such that v ≤ C.Ki
		if there is no such number i then begin
			Let Pm = last non-null pointer in the node
			Set C = C.Pm
		end
		else if (v = C.Ki ) then Set C = C.Pi+1
		else Set C = C.Pi /* v < C.Ki */
	end
	/* C is a leaf node */
	if for some i, Ki = v
		then return Pi
		else return null ; /* No record with key value v exists*/
```

1. while (当前节点不是叶节点)
   1. 检查当前节点，查找最小的i，使得搜索码值K<sub>i</sub> >= V
   2. 假如没有找到相应的i，即V >= K<sub>m-1</sub> 
      1. 将当前节点置为P<sub>m</sub> 指向的节点
   3. 假如找到了相应的i
      1. 如果V == K<sub>i</sub> ，将当前节点置为P<sub>i+1</sub> 指向的节点		// K<sub>i-1</sub> <=P<sub>i</sub> 指向的子树 < K<sub>i</sub>
      2. 否则，将当前节点置为P<sub>i</sub> 
2. 如果当前节点中存在某个i，使得K<sub>i</sub> == V
   1. 返回P<sub>i</sub> 
3. 否则，返回null



### 查找示例

查找60

![wSkk01.gif](https://s1.ax1x.com/2020/09/02/wSkk01.gif)



## 3. 插入

### 算法

1. 在B+树中查找待插入关键码V，确保V不存在，假设查找失败于叶节点`_hot`
2. 如果`_hot`中有足够多的空间，直接将关键码和指针插入`hot`
3. 如果当前节点已满
   1. 如果当前节点为叶节点
      1. 取中位数s = m / 2，将关键码划分为两组：{K<sub>1</sub>，K<sub>2</sub>，...，K<sub>s-1</sub>}，{K<sub>s</sub>，K<sub>s+1</sub>，...，K<sub>m-1</sub>}，作为两个新节点的关键码 
      2. 将关键码K<sub>s</sub> 插入父节点中，并以所得的两个节点作为左右孩子
   2. 如果当前节点为非叶节点
      1. 取中位数s = m / 2， 将关键码划分为三组：{K<sub>1</sub>，K<sub>2</sub>，...，K<sub>s-1</sub>}，{K<sub>s</sub> }，{K<sub>s+1</sub>，...，K<sub>m-1</sub>}
      2. 关键码K<sub>s</sub> 上升一层，并分裂，以所得的两个节点为左右孩子（类似B树的插入）



B+树的插入和B树的插入非常相似，但是又有一点略微的差别——B+树中如果是叶节点分裂，则需要将分界关键码（第二组关键码中的最小值）的一个拷贝插入到父节点中，B+树的非叶节点和B树的节点分裂完全相同。



### 插入示例

1. 无需分裂

![wSiTq1.gif](https://s1.ax1x.com/2020/09/02/wSiTq1.gif)



2. 分裂一次

![wSiHVx.gif](https://s1.ax1x.com/2020/09/02/wSiHVx.gif)



3. 分裂两次

![wSiba6.gif](https://s1.ax1x.com/2020/09/02/wSiba6.gif)



4. 分裂到根

![wSiqIK.gif](https://s1.ax1x.com/2020/09/02/wSiqIK.gif)



## 4. 删除

### 算法

1. 删除该关键字，如果不破坏 B+树本身的性质，直接完成操作；
2. 如果删除操作导致其该结点中最大（或最小）值改变，则应相应改动其父结点中的索引值；
3. 在删除关键字后，如果导致其结点中关键字个数不足，有两种方法：一种是向兄弟结点去借，另外一种是同兄弟结点合并。（注意这两种方式有时需要更改其父结点中的索引值。）


### 删除示例

1. 直接删除
   若当前节点中关键码个数大于`⌈(m-1)/2⌉`，可直接删除。注意：当删除节点中最大或最小关键字，涉及到更改祖先节点中索引值

   直接删除97

   ![wSFNLR.gif](https://s1.ax1x.com/2020/09/02/wSFNLR.gif)


   删除91,并改变祖先节点中索引值

   ![wSFty9.gif](https://s1.ax1x.com/2020/09/02/wSFty9.gif)

2. 旋转
   删除关键字导致当前结点中关键字个数等于`⌈(m-1)/2⌉`，若其兄弟结点中含有多余的关键字，可以从兄弟结点中借关键字完成删除操作

   删除25，从左兄弟借关键码17

   ![wSFae1.gif](https://s1.ax1x.com/2020/09/02/wSFae1.gif)



3. 合并
   如果其兄弟结点没有多余的关键字，则需要同其兄弟结点进行合并
   删除19，与左兄弟合并

   ![wSFddx.gif](https://s1.ax1x.com/2020/09/02/wSFddx.gif)



4. 合并+重新分配指针
   当进行合并时，可能会产生因合并使其双亲结点破坏 B+树的结构，需要重新分配指针

   删除30，27所在节点与其左兄弟合并，由于合并导致其父节点子女个数发生下溢，于是重新分配指针，将44所在节点分配给其父节点
   ![wSFwo6.gif](https://s1.ax1x.com/2020/09/02/wSFwo6.gif)



## 5. 总结

最后思考一个问题：为什么需要B+树？相比于B树，B+树的优越性体现在哪里？

1. 由于B+树内部节点不需要存储data pointer，所以B+树单一节点存储的元素更多，使得查询的IO次数更少
2. 所有的查询都需要查找到叶节点，查询性能是稳定的，而B树每个节点都可能查询到数据，所以不稳定。
3. 所有的叶子节点形成了一个有序链表，能更好地支持**范围查询**。

至此，B树和B+树的学习基本告一段落。和普通的数据结构相比，B树和B+树的操作显得那样的繁琐、复杂，那么我们需要强行记住这些操作吗？在此想引用Robert love关于如何学习数据结构和算法的一段话：

>现在的学生学习和理解数据结构的方法有问题。
>
>数据结构的良好基础不是对每个数据结构都知道细节怎么实现，都背下来大O复杂度和摊销复杂度，当然知道这些非常好，只是你在工作中很少用到它们，你的职业生涯里几乎不可能让你实现一个红黑树的节点删除算法。但是！！你必须知道什么时候`BST`对于一个问题是个有效的解法。
>
>所以，两个建议:
>
>1. **可视化数据结构**，把它画出来，在你的脑海中可视化，可以更好地帮助你直观地理解它
>2. 学习**什么时候**以及**如何**将不同的数据结构运用到自己的代码里。忘掉细枝末节的东西，而更关注：什么时候需要hash？什么时候需要tree？什么时候最小化堆是正确的答案？

所以，这篇文章以及上一篇文章的目的不是让读者记住B树和B+树的各种旋转、合并操作具体是如何实现的，而是想通过动画的方式，帮助读者更加直观地理解B树和B+树。